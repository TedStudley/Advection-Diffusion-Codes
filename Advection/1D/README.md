Introduction
============

This code serves the purpose of modeling advection in one-dimensional temperature advection using the finite difference method. The purpose of this code is to provide a framework for testing very simple advection problems in few lines of code. For that purpose, this README document will serve as documentation for the functions used in this framework.

This code uses the Eigen linear algebra library. Eigen can be downloaded [here](eigen.tuxfamily.org). Either install Eigen to your system include directory or directly into `Advection/1D/include`.

Documentation
=============

Field Initialization
--------------------
These codes do not use a custom object for the temperature field, instead using the Eigen `VectorXd` vector object. To define `u` as the interval [0,1] with `N` subdivisions, use `VectorXd u (N)`. 

While h, the width of each cell, is calculated for you, N--the number of subdivisions in each dimension--is not. This is due to the fact that in higher dimensions, the number of subdivisions is not completely trivial to determine from the size of the vector. To that end, it is a good idea to either set N at compile-time with a `#define` statment or to set it in a constant variable at runtime.

Initial Temperature
-------------------
The initial temperature conditions are generally functions of the form

`void (*) (Ref<VectorXd> u, unsigned int N)`

where `u` is a reference to the vector object describing the scalar temperature field and `N` is the number of subdivisions of the interval domain. The exception  to this format is the initial condition `fourierSquare`, which requires an initial temperature t0, and therefore must be called using

`void fourierSquare (Ref<VectorXd> u, unsigned int N, double t0)`.

The functions work in-place, so nothing is returned. A full catalogue of the initial conditions can be found below. Be wary of the value of `t0` for the `fourierSquare` initial condition. Choosing `t0` to be too small will result in an initial temperature which has large oscillations at the steep gradients, while choosing `t0` to be too small will result in the initial temperature being too diffused. I have found a good value for `t0` to be 0.00001.

Advection Methods
-----------------
Similar to the initial temperature conditions, the advection methods also work in-place. In general, they are functions of the form

`void (*) (Ref<VectorXd> u, unsigned int N, double v, double delta_t)`

where `u` is, again, a reference to the vector object describing the scalar temperature field, `N` is the number of subdivisions of the interval domain, `v` is the velocity of advection, and `delta_t` is the length of the current timestep. Be warned that depending on the choice of `N`, `v` and `delta_t`, the maximum stable CFL value for some advection methods may be exceeded. Most functions will attempt to warn the user if these parameters are chosen such that the CFL condition exceeds 1.0, where stability is not generally guaranteed.

Output
------
Output is handled almost entirely through Eigen. The VectorXd object can be easily output to any output stream using `operator<<`. I have found it useful to output the transpose of the temperature vector, which can be done using the `VectorXd::transpose()` member function.

Function Quickreference
=======================

Initial Temperature
-------------------

<table>
  <tr>
    <th>Function type signature</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>void squareWave (Ref&lt;VectorXd&gt;, const int)</code></td>
    <td>A simple square wave, given by <code>(0.25 &lt; x && x &lt;= 0.75) ? 1 : 0</code> ay cause problems with advection methods with bad behavior along shocks.</td>
  </tr>
  <tr>
    <td><code>void fourierSquare (Ref&lt;VectorXd&gt;, const int, const double)</code></td>
    <td>A smoothed square wave generated by taking the fourier approximation to the above square wave, then taking the exact diffusion solution at a given time <code>t0</code>. The proper choice of <code>t0</code> is important to remove oscillations due to Gibbs Phenomenon as well as prevent the initial temperature from diffusing to a blob.</td>
  </tr>
</table>


Advection Methods
-----------------

<table>
  <tr>
    <th>Function type signature</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>void upwindMethod (Ref&lt;VectorXd&gt;, const int, const double, const double)</code></td>
    <td>A simple upwind advection method. Fast and has good behavior on sharp gradients, but rather innacurate.</td>
  </tr>
  <tr>
    <td><code>void frommMethod (Ref&lt;VectorXd&gt;, const int, const double, const double)</code></td>
    <td>A second-order advection method. Still fairly fast and more accurate than upwind, but develops oscillations on sharp gradients.</td>
  </tr>
  <tr>
    <td><code>void frommVanLeer (Ref&lt;VectorXd&gt;, const int, const double, const double)</code></td>
    <td>A flux-corrected advection method. Assumes Fromm method fluxes along smooth gradients and Upwind method fluxes along sharp gradients. Slower, but accurate and has good behavior on sharp gradients.</td>
  </tr>
</table>

Sample Program
==============
A sample program to advect a square wave once around until it reaches the approximate starting position again.
```

int main() {
  const unsigned int N = 1024;
  const double delta_t = 0.0001;
  const double v       = 3.0;

  VectorXd u (N);
  squareWave (u, N);
  for (int timestep = 0; timestep < 10000; ++timestep)
    frommMethod (u, N, delta_t);
 
  cout << u.transpose () << endl;
}
```
