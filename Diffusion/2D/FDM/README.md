Introduction
============

This code serves the purpose of modeling advection in one-dimensional temperature advection using the finite difference method. The purpose of this code is to provide a framework for testing very simple advection problems in few lines of code. For that purpose, this README document will serve as documentation for the functions used in this framework.

This code uses the Eigen linear algebra library. Eigen can be downloaded [here](http://www.eigen.tuxfamily.org). Either install Eigen to your system include directory or directly into `Diffusion/1D/include`.

Documentation
=============

Field Initialization
--------------------
These codes do not use a custom object for the temperature field, instead using the Eigen `VectorXd` vector object. To define `u` as the unit square [0,1]^2 with `N` subdivisions in each spacial direction, use `VectorXd u (N * N)`. 

While h, the width of each cell, is calculated for you, N--the number of subdivisions in each dimension--is not. This is due to the fact that in higher dimensions, the number of subdivisions is not completely trivial to determine from the size of the vector. To that end, it is a good idea to either set N at compile-time with a `#define` statment or to set it in a constant variable at runtime.

Initial Temperature
-------------------
The initial temperature conditions are generally functions of the form

`void (*) (Ref<VectorXd> u, unsigned int N)`

where `u` is a reference to the vector object describing the scalar temperature field and `N` is the number of subdivisions of the interval domain. The exception  to this format is the initial condition `fourierSquare`, which requires an initial temperature t0, and therefore must be called using

`void fourierSquare (Ref<VectorXd> u, unsigned int N, double t0)`.

The functions work in-place, so nothing is returned. A full catalogue of the initial conditions can be found below. Be wary of the value of `t0` for the `fourierSquare` initial condition. Choosing `t0` to be too small will result in an initial temperature which has large oscillations at the steep gradients, while choosing `t0` to be too small will result in the initial temperature being too diffused. I have found a good value for `t0` to be 0.05.

Diffusion Methods
-----------------
Similar to the initial temperature conditions, the diffusion methods also work in-place. In general, they are functions of the form

`void (*) (Ref<VectorXd> u, const int N, const double kappa, const double delta_t)`

where `u` is, again, a reference to the vector object describing the scalar temperature field, `N` is the number of subdivisions of the interval domain, `kappa` is the coefficient of thermal diffusivity, and `delta_t` is the length of the current timestep. Be warned that depending on the choice of `N`, `kappa` and `delta_t`, the maximum stable CFL value for some diffusion methods may be exceeded. Most functions will attempt to warn the user if these parameters are chosen such that the CFL condition exceeds 0.5, where stability is not generally guaranteed.

Output
------
Output is handled through the function `displayField`. There are two ways to call `displayField`, by either specifying an output stream, or simply sending the output to `stdout`. To send output to `stdout`, you may simply call `displayField (u, N)`, where `u` is the temperature field to display, and `N` is the number of subdivisions in each spatial direction. To sent output to an arbitrary output stream, call `displayField (u, N, stream)`, where `u` and `N` are defined as before, and `stream` is the output stream to be written to.

Included in the same folder as this README is the bash script `plotscript`. If your computer can run bash scripts and has gnuplot, you can run this script to automatically plot output files from diffusion-2d. Just run it using `./plotscript &lt;input&gt; &lt;size&gt; &lt;output&gt;` where `&lt;input&gt;` is your outputted data from diffusion-2d, `&lt;size&gt;` is the size of the input (`N` from inside diffusion-2d), and `&lt;output&gt;` is the file to output to. Currently, plotscript only outputs to vector graphics files, although it is trivial to change the output type by editing the script.

Function Quickreference
=======================

Initial Temperature
-------------------

<table>
  <tr>
    <th>Function type signature</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>void squareWave (Ref&lt;VectorXd&gt;, const int)</code></td>
    <td>A simple square wave, given by <code>(0.25 &lt; x && x &lt;= 0.75) ? 1 : 0</code> may cause problems with diffusion methods which exhibit bad behavior along shocks.</td>
  </tr>
  <tr>
    <td><code>void fourierSquare (Ref&lt;VectorXd&gt;, const int, const double)</code></td>
    <td>A smoothed square wave generated by taking the fourier approximation to the above square wave, then taking the exact diffusion solution at a given time <code>t0</code>. The proper choice of <code>t0</code> is important to remove oscillations due to Gibbs Phenomenon as well as prevent the initial temperature from diffusing to a blob.</td>
  </tr>
</table>


Advection Methods
-----------------

<table>
  <tr>
    <th>Function type signature</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>void forwardEuler (Ref&lt;VectorXd&gt; u, const int N, const double kappa, const double delta_t)</code></td>
    <td>A simple explicit diffusion method. Fast and fairly accurate, but unstable.</td>
  </tr>
  <tr>
    <td><code>void backwardEuler (Ref&lt;VectorXd&gt; u, const int N, const double kappa, const double delta_t)</code></td>
    <td>A simple implicit diffusion method. Fairly fast, but with less accuracy. This method is unconditionally stable, and should never introduce oscillations due to sharp gradients.</td>
  </tr>
  <tr>
    <td><code>void crankNicolson (Ref&lt;VectorXd&gt; u, const int N, const double kappa, const double delta_t, const double c = 0.5)</code></td>
    <td>A centered-difference diffusion method. Uses half of a step of Forward Euler and then half of a step of Backward Euler. Unconditionally stable, but may develop oscillations at sharp gradients.</td>
  </tr>
</table>

Sample Program
==============
```C++

int main() {
  const unsigned int N = 64;
  const double delta_t = 5e-6;
  const double kappa   = 0.0675;

  VectorXd u (N * N);
  squareWave (u, N);
  for (int timestep = 0; timestep < 100; ++timestep)
    forwardEuler (u, N, kappa, delta_t);
 
  cout << u.transpose () << endl;
}
```
